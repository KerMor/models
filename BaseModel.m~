classdef BaseModel < handle
    %BASEMODEL Base class for both full and reduced models.
    %   This class gathers all common functionalities of models in the
    %   KerMor framework.
    %   The most important method would be @code [t,y] =
    %   simulate(mu,inputidx) @endcode which computes the system's solution
    %   for given `\mu` and input number (if applicable).
    %   Also a plot wrapper is provided that refers to the plotting methods
    %   within the model's system.
    %
    % @author Daniel Wirtz @date 19.03.2010
    
    properties
        % The actual dynamical system used in the model.
        System;
        
        % The name of the Model
        Name = 'Base Model';
        
        % The verbose output level at simulations
        Verbose = 0;
        
        % The final timestep up to which to simulate.
        %
        % NOTE: When changing this property any offline computations have
        % to be repeated in order to obtain a new reduced model.
        T = 1;
        
        % The desired time-stepsize for simulations
        %
        % NOTE: When changing this property any offline computations have
        % to be repeated in order to obtain a new reduced model.
        dt = .1;
        
        % The solver to use for the ODE.
        % Must be an instance of any solvers.BaseSolver subclass.
        %
        % See also: solvers BaseSolver ode23 ode45 ode113
        ODESolver;
        
        % The custom scalar product matrix
        %
        % In some settings the state variables have a special meaning (like
        % DOF's in FEM simulations) where the pure `L^2`-norm has less
        % meaning than a custom norm induced by a symmetric positive
        % definite matrix G. If `d\in\mathbb{N}` is the number of state
        % variables (i.e. dimensions of `x(t)`), then we must have
        % `G\in\mathbb{R}^{d\times d}`.
        %
        % Leave at `1\in\mathbb{R}` if `G=I_d` should be assumed.
        %
        % Default:
        % 1
        G = 1;
    end
    
    properties(Dependent)
        % Evaluation points of the model as increasing array
        Times;
    end
    
    properties(Access=protected)
        % Flag that indicates changes in either T or dt after
        % offlineGenerations have been performed.
        TimeDirty;
    end
    
    methods
        
        function this = BaseModel
             this.System = models.BaseDynSystem;
        end
        
        function [t,y,sec] = simulate(this, mu, inputidx)
            % Simulates the system and produces the system's output.
            %
            % Both parameters are optional. (Which to provide will be
            % determined by the actual system anyways)
            %
            % Parameters:
            % mu: The concrete mu parameter sample to simulate for.
            % inputidx: The index of the input function to use.
            %
            % Return values:
            % t: The times at which the model was evaluated
            % y: Depending on the existance of an output converter, this
            %    either returns the full trajectory or the processed output
            %    at times t.
            % sec: the seconds needed for simulation.
            
            if nargin < 3
                if ~isempty(this.System.Inputs)
                    warning('BaseModel:NoInputSpecified',['You must specify'...
                        'an input index if inputs are set up. Using inputidx=1']);
                    inputidx = 1;
                else
                    inputidx = [];
                end
                if nargin < 2
                    mu = [];
                end
            end
            if isempty(mu) && ~isempty(this.System.Params)
                error('A model with parameters cannot be simulated without a parameter argument.');
            end
            
            starttime = tic;
            
            [t,x] = this.computeTrajectory(mu, inputidx);
            
            if ~isempty(this.System.C)
                if this.System.C.TimeDependent
                    % Evaluate the output conversion at each time t
                    % Figure out resulting size of C*x evaluation
                    hlp = this.System.C.evaluate(t(1),mu)*x(:,1);
                    y = zeros(size(hlp,1),length(t));
                    y(:,1) = hlp;
                    for idx=2:length(t)
                        y(:,idx) = this.System.C.evaluate(t(idx),mu)*x(:,idx);
                    end
                else
                    % otherwise it's a constant matrix so multiplication
                    % can be preformed much faster.
                    y = this.System.C.evaluate([],mu)*x;
                end
            else
                warning('KerMor:NoOutputConversion',['No system output'...
                    'conversion set. Forgot to set property C? Result'...
                    'equals state variables.']);
                y = x;
            end
            
            sec = toc(starttime);
        end
        
        function plot(this, t, y)
            % Plots the results of the simulation.
            % Override in subclasses for a more specific plot if desired.
            figure;
            plot(t,y);
            title(sprintf('Plot for output of model "%s"', this.Name));
            xlabel('Time'); ylabel('Output functions');
        end
        
    end
    
    methods
        
        function [t,x] = computeTrajectory(this, mu, inputidx)
            % Computes a solution/trajectory for the given mu and inputidx.
            %
            % Return values:
            % t: The times at which the model was evaluated. Will equal
            % the property Times
            % x: Depending on the existance of an output converter, this
            %    either returns the full trajectory or the processed output
            %    at times t.
            
            % Setup simulation-time constant data (if available)
            if isa(this.System,'ISimConstants')
                this.System.updateSimConstants;
            end
            if isa(this.System.f,'ISimConstants')
                this.System.f.updateSimConstants;
            end

            % Get target ODE function
            if isempty(this.System.f)
                error('No system''s core function specified. ODE function creation impossible; first set "f" property.');
            end
            odefun = this.System.getODEFun(mu, inputidx);
            
            % Get initial x0
            x0 = this.getX0(mu);
            
            % Solve ODE
            [t,x] = this.ODESolver.solve(odefun, this.Times, x0, opts);
            
            % Transpose result to match inner data structure
            x = x';
        end
    end
    
    methods(Access=protected)
        function x0 = getX0(this, mu)
            % Gets the initial state variable at `t=0`.
            %
            % This is exported into an extra function as it gets overridden
            % in the ReducedModel subclass, where ErrorEstimators possibly
            % change the x0 dimension.
            %
            % Parameters:
            % mu: The parameter `\mu` to evaluate `x_0(\mu)`. Use [] for
            % none.
            x0 = this.System.x0(mu);
        end
    end
    
    methods(Access=protected,Sealed)
               
        function checkType(this, obj, type)%#ok
            % Object typechecker.
            % Checks if a given object is of the specified type and throws
            % an error if not.
            % Convenience method.
            if ~isempty(obj) && ~isa(obj, type)
                error(['Wrong type ''' class(obj) ''' for this property. Has to be a ' type]);
            end
        end
    end
    
    %% Getter & Setter
    methods
        function value = get.Times(this)
            value = 0:this.dt:this.T;
        end
        
        function set.T(this, value)
            if ~isposrealscalar(value)
                error('T must be a positive real scalar.');
            end
            if this.T ~= value
                this.T = value;
                this.TimeDirty = true;%#ok
            end
        end
        
        function set.dt(this, value)
            if ~isposrealscalar(value)
                error('T must be a positive real scalar.');
            end
            if this.dt ~= value
                this.dt = value;
                this.TimeDirty = true;%#ok
            end
        end
        
        function set.G(this, value)
            % @todo check for p.d. and symmetric, -> sparsity?
            this.G = value;
        end
        
        function set.ODESolver(this, value)
            this.checkType(value
        end
    end
end

