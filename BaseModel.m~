classdef BaseModel < handle
    %BASEMODEL Base class for both full and reduced models.
    %   This class gathers all common functionalities of models in the
    %   KerMor framework.
    %   The most important method would be @code [t,y] =
    %   simulate(mu,inputidx) @endcode which computes the system's solution
    %   for given `\mu` and input number (if applicable).
    %   Also a plot wrapper is provided that refers to the plotting methods
    %   within the model's system.
    %
    % @DanielWirtz, 19.03.2010
    
    properties
        % The actual dynamical system used in the model.
        System;
        
        % The name of the Model
        Name = 'Base Model';
        
        % The verbose output level at simulations
        Verbose = 0;
        
        % The final timestep up to which to simulate.
        %
        % NOTE: When changing this property any offline computations have
        % to be repeated in order to obtain a new reduced model.
        T = 1;
        
        % The desired time-stepsize for simulations
        %
        % NOTE: When changing this property any offline computations have
        % to be repeated in order to obtain a new reduced model.
        dt = .1;
        
        % The solver to use for the ODE.
        % This property must be a function handle with a signature
        % equivalent to those of the matlab built-in ode solver functions.
        %
        % See also: ode23 ode45 ode113
        ODESolver = @ode45;
    end
    
    properties(Dependent)
        % Evaluation points of the model as increasing array
        Times;
    end
    
    methods
        
        function this = BaseModel
             this.System = models.BaseDynSystem;
        end
        
        function [t,y,sec] = simulate(this, mu, inputidx)
            % Simulates the system and produces the system's output.
            %
            % Parameters:
            % mu: The concrete mu parameter sample to simulate for.
            % inputidx: The index of the input function to use.
            %
            % Both parameters are optional. (Which to provide will be
            % determined by the actual system anyways)
            %
            % Return values:
            % t: The times at which the model was evaluated
            % y: Depending on the existance of an output converter, this
            %    either returns the full trajectory or the processed output
            %    at times t.
            % sec: the seconds needed for simulation.
            
            if nargin < 3
                if ~isempty(this.System.Inputs)
                    warning('BaseModel:NoInputSpecified',['You must specify'...
                        'an input index if inputs are set up. Using inputidx=1']);
                    inputidx = 1;
                else
                    inputidx = [];
                end
                if nargin < 2
                    mu = [];
                end
            end
            if isempty(mu) && ~isempty(this.System.Params)
                error('A model with parameters cannot be simulated without a parameter argument.');
            end
            
            starttime = tic;
            
            [t,x] = this.computeTrajectory(mu, inputidx);
            
            if ~isempty(this.System.C)
                if this.System.C.TimeDependent
                    % Evaluate the output conversion at each time t
                    hlp = this.System.C.evaluate(t(1),mu)*x(:,1);
                    y = zeros(size(hlp,
                    for idx=1:length(t)
                        y(:,idx) = this.System.C.evaluate(t(idx),mu)*x(:,idx);
                    end
                else
                    % otherwise it's a constant matrix so multiplication
                    % can be preformed much faster.
                    y = this.System.C.evaluate([],mu)*x;
                end
            else
                warning('KerMor:NoOutputConversion',['No system output'...
                    'conversion set. Forgot to set property C? Result'...
                    'equals state variables.']);
            end
            
            sec = toc(starttime);
        end
        
        function value = get.Times(this)
            value = 0:this.dt:this.T;
        end
    end
    
    methods(Sealed)
        function plot(this, t, y)
            % Forwards a plot request to the current system passing the
            % instance of the current model.
            %
            this.System.plot(this, t, y);
        end
    end
    
    methods(Access=protected,Sealed)
        
        function [t,x] = computeTrajectory(this, mu, inputidx)
            % Computes a solution/trajectory for the given mu and inputidx.
            %
            % Parameters:
            % mu: The concrete mu parameter sample to simulate for.
            % inputidx: The index of the input function to use.
            %
            % Leave parameters empty if the system does not have the
            % according features (it will be ignored anyway)
            %
            % Return values:
            % t: The times at which the model was evaluated
            % x: Depending on the existance of an output converter, this
            %    either returns the full trajectory or the processed output
            %    at times t.
            
            % Set ODE options
            opts = [];
            if ~isempty(this.System.MaxTimestep)
                opts = odeset('MaxStep',this.System.MaxTimestep, 'InitialStep',.5*this.System.MaxTimestep);
            end
            
            % Setup simulation-time constant data (if available)
            if isa(this.System,'ISimConstants')
                this.System.updateSimConstants;
            end
            if isa(this.System.f,'ISimConstants')
                this.System.f.updateSimConstants;
            end
            
            % Get target ODE function
            odefun = this.System.getODEFun(mu, inputidx);
            
            % Get initial x
            x0 = this.System.x0(mu);
            
            % Solve ODE
            [t,x] = this.ODESolver(odefun, this.Times, x0, opts);
            % Transpose result to match inner data structure
            x = x';
        end
        
        function checkType(this, obj, type)%#ok
            % Object typechecker.
            % Checks if a given object is of the specified type and throws
            % an error if not.
            % Convenience method.
            if ~isempty(obj) && ~isa(obj, type)
                error(['Wrong type ''' class(obj) ''' for this property. Has to be a ' type]);
            end
        end
    end
end

