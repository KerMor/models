classdef ReducedModel < models.BaseModel
    % The KerMor reduced model class
    %
    % In difference to the BaseModels this class cannot be extended. All
    % needed functionality for reduced models is included here (simulation,
    % error computation etc) and no specific subclasses for other models
    % need to be implemented. One can obtain a reduced model from a full
    % model by calling the full model's @code buildReducedModel @endcode
    % function. Dont forget to call @code offlineGenerations @endcode at
    % least once before reduction.
    %
    % See also: BaseModel BaseFullModel
    %
    % @author Daniel Wirtz @date 23.03.2010
    
    properties(SetAccess=private)
        
        % The full model this reduced model was created from.
        %
        % Once an instance of a reduced model gets saved to disk, the
        % FullModels .Data and .Approx properties get set to [] for disk
        % space reduction since these properties are not necessarily used
        % by the reduced system. So far, only error computations will take
        % longer since the initial snapshots are not available anymore.
        FullModel;
        
        % The matrix that has been used for projection
        %
        V;
        
        % The biorthogonal matrix for V, i.e. `W^tV = I_d`
        %
        W;
        
        % The originally used parameter samples.
        %
        % The parameter samples that have been used for computation of the
        % reduced model.
        ParamSamples;
        
    end
    
    properties
        % The error estimator for the reduced model
        %
        %
        %
        % @type error.BaseEstimator
        ErrorEstimator;
    end
    
    methods(Sealed)
        
        function this = ReducedModel(fullmodel)
            % Creates a reduced model from a given full model.
            %
            % @docupdate
            if nargin == 0 || ~isa(fullmodel,'models.BaseFullModel')
                error('ReducedModel instances require a full model to construct from.');
            end
            
            % Check if a reduction is available at all
            if isempty(fullmodel.Approx) && isempty(fullmodel.SpaceReducer)
                warning('KerMor:Reducing:noEffectiveReduction',...
                    ['Model setup lacks reduction methods.\n'...
                    'Reduced model will equal the full model (computationally).']);
            end
            
            disp('Start building reduced model...');
            % IMPORTANT: Assign any model properties that are used during
            % the creation of the reduced system! (i.e. V,W are used in the
            % constructor of the reduced System)
            this.FullModel = fullmodel;
            % Update name ;-)
            this.Name = ['Reduced: ' fullmodel.Name];
            
            % Copy common values from the full model
            this.T = fullmodel.T;
            this.dt = fullmodel.dt;
            this.Verbose = fullmodel.Verbose;
            this.ODESolver = fullmodel.ODESolver;
            this.G = fullmodel.G;
            
            % Copy data that is also needed in the reduced model
            this.V = fullmodel.Data.V;
            this.W = fullmodel.Data.W;
            this.ParamSamples = fullmodel.Data.ParamSamples;
            
            % Create a new reducedSystem passing the full and so far
            % initialized reduced models
            this.System = models.ReducedSystem(fullmodel,this);
            
            % Obtain an error estimator. The static method looks for a
            % suitable error estimator or returns the default (=expensive!)
            % estimator.
            this.ErrorEstimator = error.BaseEstimator.getEstimator(this);
        end
        
        function [t,x] = computeTrajectory(this, mu, inputidx)
            % Call parent method for actual work
            % @docupdate
            
            % Clear possibly old data in error estimators
            this.ErrorEstimator.clear;
            
            % Call inherited method (actual work)
            [t,xtmp] = computeTrajectory@models.BaseModel(this, mu, inputidx);
            
            % Split up results; the last row of the ode solution contains
            % any online-computable errors
            if this.ErrorEstimator.Enabled
                x = xtmp(1:end-this.ErrorEstimator.ExtraODEDims,:);
                this.ErrorEstimator.process(t, xtmp, mu, inputidx);
            else
                x = xtmp;
            end
        end
        
        function exo = getExo(this, mu)
            % Computes the norm of the initial error `E_{x_0}(\mu)`
            if ~isempty(this.V) && ~isempty(this.W)
                x0 = this.FullModel.System.x0(mu);
                y = this.W'*x0;
                GV = this.G*this.V;
                exo = x0'*this.G*x0 -x0'*GV*y - y'*this.V'*this.G*x0 + y'*this.V'*GV*y;
                exo = sqrt(max(exo,0));
            else
                exo = 0;
            end
        end
        
        function [t,e,est] = getError(this, varargin)
            % Gets the reduced model's error for a specified parameter and
            % input.
            %
            % @todo possibly move into BaseEstimator?
            
            [t,x,xr] = this.getTrajectories(varargin{:});
            % Compute L^2-norm of difference for each timestep
            e = sqrt(sum((x - xr).^2,1));
            est = this.ErrorEstimator.LastError;
        end
        
        function [t,erel,estrel] = getRelativeError(this, varargin)
            [t,x,xr] = this.getTrajectories(varargin{:});
            e = sqrt(sum((x - xr).^2,1));
            est = this.ErrorEstimator.LastError;
            x = sqrt(sum(x.^2,1));
            erel = e./x;
            estrel = est./x;
        end
        
        function analyze(this, mu, inputidx)
            if nargin < 3
                inputidx = 1;
                if nargin < 2
                    mu = [];
                end
            end
            [t,x,xr,time,timer,timer_noerr] = this.getTrajectories(mu, inputidx);
            e = sqrt(sum((x - xr).^2,1));
            est = this.ErrorEstimator.LastError;
            xnorm = sqrt(sum(x.^2,1));
            erel = e./xnorm;
            estrel = est./xnorm;
            xrnorm = sqrt(sum(xr.^2,1));
            erelr = e./xrnorm;
            estrelr = est./xrnorm;
            
            % System plot
            h = figure;
            pos = get(0,'MonitorPosition');
            set(h,'OuterPosition',pos(1,:));
            subplot(2,3,1);
            plot(t,x);
            xlabel('t');
            title(sprintf('The full system (d=%d,time=%.3f)',size(x,1),time));
            subplot(2,3,2);
            plot(t,xr);
            xlabel('t');
            title(sprintf('The reduced system (r=%d,self time:%.3f, time with err est:%.3f)',size(this.V,2),timer_noerr,timer));
            
            % Absolute value plot
            subplot(2,3,3);
            plot(t,xnorm,'r',t,xrnorm,'b');
            xlabel('t');
            title('The state variable norms');
            legend('Full system','Reduced system');%,'Location','Best');
            
            % Error plots
            subplot(2,3,4);
            plot(t,e,'r',t,est,'b');%,t,abs(e-est),'g');
            xlabel('t');
            title(sprintf('The state variable absolute errors.\nmean(e)=%g, mean(est)=%g',mean(e),mean(est)));
            legend('True error','Estimated error');%,'Location','Best');
            
            % Relative Error plots
            subplot(2,3,5);
            plot(t,erel,'r',t,estrel,'b');
            xlabel('t');
            title(sprintf(['The state variable relative errors (comp. to '...
                'full solution)\nmean(e_{rel})=%g, mean(est_{rel})=%g'],...
                mean(erel),mean(estrel)));
            legend('True error','Estimated error');%,'Location','Best');
            
            subplot(2,3,6);
            plot(t,erelr,'r',t,estrelr,'b');
            xlabel('t');
            title(sprintf(['The state variable relative errors (comp. to '...
                'reduced solution)\nmean(ered_{rel})=%g, mean(estred_{rel})=%g'],...
                mean(erelr),mean(estrelr)));
            legend('True error','Estimated error');%,'Location','Best');
        end
        
        function compareCore_Approx(this)
            num = 10;
            d = this.FullModel.Data;
            
            sn = d.PlainSnapshotArray;
            xi = sn(2:end,:);
            ti = sn(1,:);
            
            idx = reshape(repmat(1:size(d.ParamSamples,2),size(d.Snapshots,2),1),1,[]);
            mui = d.ParamSamples(:,idx);
            
            afx = this.FullModel.Approx.evaluate(xi,ti,mui);
            %afx = afx(1:num,:);
            len = size(afx,2);
            for idx = 1:num
                %sn(idx,:) = %reshape(this.FullModel.Data.Snapshots(idx,:,:,:),1,[]);
                %fx(idx,:) = reshape(d.fValues(idx,:,:,:),1,[]);
                fx = reshape(d.fValues(idx,:,:,:),1,[]);
                plot(1:len,fx,1:len,afx(idx,:));
                pause;
            end
            
            %plot(1:len,fx,1:len,afx,'--');
            
            arfx = this.System.f.evaluate(d.V'*xi,ti,mui);
            rfx = d.V'*d.fValues(:,:);
        end
        
        function save(this, matfile)
            % Saves the reduced model to disk.
            %
            % Parameters:
            % matfile: The target file. If not specified, a file with the
            % name of the reduced model's variable name is used.
            
            name = inputname(1);
            if nargin == 1
                matfile = fullfile(cd,name);
            end
            % For the save process of the reduced model the full model's
            % Data (=ModelData) and Approx properties are not needed. This
            % is the fastest way to ensure that the reduced model can still
            % have access to all important features of the full model but
            % uses less disk space.
            m = this.FullModel;
            d = m.Data;
            a = m.Approx;
            
            m.Data = [];
            m.Approx = [];
            
            eval([name ' = this;']);
            save(matfile,name);
            
            m.Data = d;
            m.Approx = a;
        end
        
    end
    
    methods(Access=protected,Sealed)
        function x0 = getX0(this, mu)
            % Gets the initial value of `x_0(\mu)`.
            %
            % If the estimator is enabled, x0 is extended by the e0
            % components of the error estimator.
            x0 = getX0@models.BaseModel(this, mu);
            if this.ErrorEstimator.Enabled
                x0 = [x0; this.ErrorEstimator.getE0(mu)];
            end
        end
    end
    
    methods
        
        function [t,x,xr,time,timer,t_noerr] = getTrajectories(this, mu, inputidx)
            % Debug Method. Computes the trajectories of the full, reduced
            % and reduced without error estimation systems.
            if nargin < 3
                inputidx=[];
                if nargin < 2
                    mu = [];
                end
            end
            % Perform full simulation (computed trajectories are cached!)
            tic;
            [t,x] = this.FullModel.computeTrajectory(mu, inputidx);
            time = toc;
            % Perform reduced simulation
            this.ErrorEstimator.Enabled = false;
            tic;
            [t,z] = this.computeTrajectory(mu, inputidx);
            xr = this.V*z;%#ok
            t_noerr = toc;
            this.ErrorEstimator.Enabled = true;
            tic;
            [t,z] = this.computeTrajectory(mu, inputidx);
            xr = this.V*z;
            timer = toc;
        end
        
        function set.ErrorEstimator(this, value)
            if ~isa(value,'error.BaseEstimator')
                error('The ErrorEstimator property must be a subclass of the error.BaseEstimator class.');
            end
            msg = value.validModelForEstimator(this);
            if ~isempty(msg)
                error(msg);
            end
            this.ErrorEstimator = value;
        end
    end
    
    %         function [vals, repmu] = getSamplesForParam(this, pidx)
    %             % Gets the samples from the ParamSamples that are equal in all
    %             % other params but the one given through pidx.
    %             %
    %             % Return values:
    %             % vals: The sorted, unique values for parameter pidx in
    %             % ParamSamples.
    %             % repmu: The representative parameter vector that contains the
    %             % param values for all others but the pidx' parameter.
    %             %
    %             % Note: Since there may be more values of the pidx' param but
    %             % some having different parameter vectors here the vector of
    %             % the first smallest pidx' param is taken as representative
    %             % vector.
    %             ps = this.ParamSamples;
    %             numparams = this.System.ParamCount;
    %             numsamples = size(ps,2);
    %             paridx = 1:numparams;
    %
    %             % Sort values of current param
    %             [tmp, idx] = sort(ps(pidx,:));
    %             % Get index of lowest value to have something to start
    %             % with
    %             first = idx(1);
    %             % figure out the leftover indices
    %             restpar = paridx;
    %             restpar(pidx) = [];
    %
    %             % get comparing vector (whole column but the current
    %             % parameter's index)
    %             cmp = ps(restpar,first);
    %             % find columns that are equal to cmp in the whole
    %             % column but at the current param's index
    %             all = sum(repmat(cmp,1,numsamples) == ps(restpar,:),1) == (numparams-1);
    %
    %             vals = sort(unique(ps(pidx,all)));
    %             repmu = ps(:,first);
    %         end
    
    
    %% Save & Load
    %     methods
    %         function S = saveobj(obj)
    %             % Just save everything straight
    %             S.fData = obj.fData;
    %             S.fSource = obj.fSource;
    %             S.SubpartOffset = obj.SubpartOffset;
    %             S.Range = obj.Range;
    %             S.InitialSize = obj.InitialSize;
    %             S.LevelSetData = obj.LevelSetData;
    %             S.Regions = obj.Regions;
    %             S.Info = obj.Info;
    %             S.View = obj.View;
    %         end
    %
    %         function obj = reload(obj,S)
    %             obj.fData = S.fData;
    %             obj.SubpartOffset = S.SubpartOffset;
    %             % Important: fSource and SubpartOffset have to be set before
    %             % the range parameter is set.
    %             obj.Range = S.Range;
    %             % Leftover props
    %             obj.InitialSize = S.InitialSize;
    %             obj.LevelSetData = S.LevelSetData;
    %             obj.Regions = S.Regions;
    %             obj.Info = S.Info;
    %             obj.View = S.View;
    %         end
    %     end
    %
    %     methods (Static)
    %         function obj = loadobj(S)
    %             a = S.fSource;
    %             obj = segmentation(sourceimage(S.fSource));
    %             obj = reload(obj,S);
    %         end
    %     end
    
end

