classdef ReducedModel < models.BaseModel
    % The KerMor reduced model class
    %
    % In difference to the BaseModels this class cannot be extended. All
    % needed functionality for reduced models is included here (simulation,
    % error computation etc) and no specific subclasses for other models
    % need to be implemented. One can obtain a reduced model from a full
    % model by calling the full model's @code buildReducedModel @endcode
    % function. Dont forget to call @code offlineGenerations @endcode at
    % least once before reduction.
    %
    % See also: BaseModel BaseFullModel
    %
    % @author Daniel Wirtz @date 23.03.2010
    
    properties(SetAccess=private)
        
        % The full model this reduced model was created from.
        %
        % Once an instance of a reduced model gets saved to disk, the
        % FullModels .Data and .Approx properties get set to [] for disk
        % space reduction since these properties are not necessarily used
        % by the reduced system. So far, only error computations will take
        % longer since the initial snapshots are not available anymore.
        FullModel;
        
        % The matrix that has been used for projection
        %
        V;
        
        % The biorthogonal matrix for V, i.e. `W^tV = I_d`
        %
        W;
        
        % The originally used parameter samples.
        %
        % The parameter samples that have been used for computation of the
        % reduced model.
        ParamSamples;
        
        % The error estimator for the reduced model
        %
        %
        %
        % @type error.BaseEstimator
        ErrorEstimator;
    end
    
    methods(Sealed)
        
        function this = ReducedModel(fullmodel)
            % Creates a reduced model from a given full model.
            %
            % @docupdate
            if nargin == 0 || ~isa(fullmodel,'models.BaseFullModel')
                error('ReducedModel instances require a full model to construct from.');
            end
            
            % Check if a reduction is available at all
            if isempty(fullmodel.Approx) && isempty(fullmodel.SpaceReducer)
                warning('KerMor:Reducing:noEffectiveReduction',...
                    ['Model setup lacks reduction methods.\n'...
                    'Reduced model will equal the full model (computationally).']);
            end
            
            
            % IMPORTANT: Assign any model properties that are used during
            % the creation of the reduced system! (i.e. V,W are used in the
            % constructor of the reduced System)
            this.FullModel = fullmodel;
            % Update name ;-)
            this.Name = ['Reduced: ' fullmodel.Name];
            
            % Copy common values from the full model
            this.T = fullmodel.T;
            this.dt = fullmodel.dt;
            this.Verbose = fullmodel.Verbose;
            this.ODESolver = fullmodel.ODESolver;
            this.G = fullmodel.G;
            
            % Copy data that is also needed in the reduced model
            this.V = fullmodel.Data.V;
            this.W = fullmodel.Data.W;
            this.ParamSamples = fullmodel.Data.ParamSamples;
            
            % Create a new reducedSystem passing the full and so far
            % initialized reduced models
            this.System = models.ReducedSystem(fullmodel,this);
            
            % Obtain an error estimator. The static method looks for a
            % suitable error estimator or returns the default (=expensive!)
            % estimator.
            this.ErrorEstimator = error.BaseEstimator.getEstimator(this);
        end
        
        function [t,x] = computeTrajectory(this, mu, inputidx)
            % Call parent method for actual work
            % @docupdate
            [t,xtmp] = computeTrajectory@models.BaseModel(this, mu, inputidx);
            
            % Split up results; the last row of the ode solution contains
            % any online-computable errors
            if this.ErrorEstimator.Enabled
                x = xtmp(1:end-this.ErrorEstimator.ExtraODEDims,:);
                this.ErrorEstimator.process(t, xtmp, mu, inputidx);
            else
                x = xtmp;
            end
        end
        
        function exo = getExo(this, mu)
            % Computes the norm of the initial error `E_{x_0}(\mu)`
            if ~isempty(this.V) && ~isempty(this.W)
                x0 = this.FullModel.System.x0(mu);
                y = this.W'*x0;
                GV = this.G*this.V;
                exo = x0'*this.G*x0 -x0'*GV*y - y'*this.V'*this.G*x0 + y'*this.V'*GV*y;
                exo = sqrt(max(exo,0));
            else
                exo = 0;
            end
        end
        
        
%         function getReductionErrorsParamWise(this)
%             % Gets the reduced model's errors per parameter.
%             %
%             % @todo possibly move into BaseEstimator?
%             numparams = this.System.ParamCount;
%             figure(1);
%             plotcnt = 1;
%             for pidx = 1:numparams
%                 p = this.System.Params(pidx);
%                 % Only bother to compute error along parameter if
%                 if p.HasRange
%                     [vals, repmu] = this.getSamplesForParam(pidx);
%                     
%                     % Add up some more parameter values
%                     news = linspace(p.MinVal,p.MaxVal,2*p.Desired-1);
%                     vals = sort(union(vals,news));
%                     musam = repmat(repmu,1,length(vals));
%                     musam(pidx,:) = vals;
%                     
%                     e = zeros(length(vals),length(this.Times));
%                     for sidx = 1:size(musam,2)
%                         [t,et] = this.getError(musam(:,sidx),1);
%                         e(sidx,:) = et;
%                     end
%                     % Plot it!
%                     subplot(1,plotcnt,plotcnt);
%                     mesh(this.Times,vals,e);
%                     xlabel('Time');
%                     ylabel(sprintf('Range for %s',p.Name));
%                     title(sprintf('Errors for ''%s'', parameter %s',this.Name,p.Name));
%                     plotcnt = plotcnt+1;
%                 end
%             end
%         end
        
        function [t,e,est] = getError(this, varargin)
            % Gets the reduced model's error for a specified parameter and
            % input.
            %
            % @todo possibly move into BaseEstimator?
            
            [t,x,xr] = this.getTrajectories(varargin{:});
            % Compute L^2-norm of difference for each timestep
            e = sqrt(sum((x - xr).^2,1));
            est = this.ErrorEstimator.LastError;
        end
        
        function [t,erel,estrel] = getRelativeError(this, varargin)
            [t,x,xr] = this.getTrajectories(varargin{:});
            e = sqrt(sum((x - xr).^2,1));
            est = this.ErrorEstimator.LastError;
            x = sqrt(sum(x.^2,1));
            erel = e./x;
            estrel = est./x;
        end
        
        function analyze(this, mu, inputidx)
            if nargin < 3
                inputidx = 1;
                if nargin < 2
                    mu = [];
                end
            end
            [t,x,xr,time,timer,timer_noerr] = this.getTrajectories(mu, inputidx);
            e = sqrt(sum((x - xr).^2,1));
            est = this.ErrorEstimator.LastError;
            xnorm = sqrt(sum(x.^2,1));
            erel = e./xnorm;
            estrel = est./xnorm;
            xrnorm = sqrt(sum(xr.^2,1));
            erelr = e./xrnorm;
            estrelr = est./xrnorm;
            
            % System plot
            h = figure;
            set(h,'OuterPosition',get(h
            subplot(2,3,1);
            plot(t,x);
            xlabel('t');
            title(sprintf('The full system (d=%d,time=%.3f)',size(x,1),time));
            subplot(2,3,2);
            plot(t,x);
            xlabel('t');
            title(sprintf('The reduced system (r=%d,self time:%.3f, time with err est:%.3f)',size(this.V,2),timer_noerr,timer));
            
            % Absolute value plot
            subplot(2,3,3);
            plot(t,xnorm,'r',t,xrnorm,'b');
            xlabel('t');
            title('The state variable norms');
            legend('Full system','Reduced system');%,'Location','Best');
            
            % Error plots
            subplot(2,3,4);
            plot(t,e,'r',t,est,'b');%,t,abs(e-est),'g');
            xlabel('t');
            title(sprintf('The state variable absolute errors.\nmean(e)=%g, mean(est)=%g',mean(e),mean(est)));
            legend('True error','Estimated error');%,'Location','Best');
            
            % Relative Error plots
            subplot(2,3,5);
            plot(t,erel,'r',t,estrel,'b');
            xlabel('t');
            title(sprintf(['The state variable relative errors (comp. to '...
                           'full solution)\nmean(e_{rel})=%g, mean(est_{rel})=%g'],...
                           mean(erel),mean(estrel)));
            legend('True error','Estimated error');%,'Location','Best');
            
            subplot(2,3,6);
            plot(t,erelr,'r',t,estrelr,'b');
            xlabel('t');
            title(sprintf(['The state variable relative errors (comp. to '...
                           'reduced solution)\nmean(ered_{rel})=%g, mean(estred_{rel})=%g'],...
                           mean(erelr),mean(estrelr)));
            legend('True error','Estimated error');%,'Location','Best');
        end
        
%         function compareTargetFcn(this)
%             if ~isempty(this.FullModel.Data)
%                 md = this.FullModel.Data;
%                 sn = md.Snapshots;
%                 fVal = md.fValues;
%                 
%                 for pidx = 1:size(sn,3)
%                     for inidx=1:size(sn,4)
%                         x = sn(:,:,pidx,inidx);
%                         orig_f = fVal(:,:,pidx,inidx);
%                         mu = md.ParamSamples(:,pidx);
%                         approx_f = this.System.f.evaluate(x,this.Times,mu);
%                         plot(1:sntotal,orig_f,'r',1:sntotal,approx_f,'b');
%                     end
%                 end
%             end
%         end
        
        function save(this, matfile)
            % Saves the reduced model to disk.
            %
            % Parameters:
            % matfile: The target file. If not specified, a file with the
            % name of the reduced model's variable name is used.
            
            name = inputname(1);
            if nargin == 1
                matfile = fullfile(cd,name);
            end
            % For the save process of the reduced model the full model's
            % Data (=ModelData) and Approx properties are not needed. This
            % is the fastest way to ensure that the reduced model can still
            % have access to all important features of the full model but
            % uses less disk space.
            m = this.FullModel;
            d = m.Data;
            a = m.Approx;
            
            m.Data = [];
            m.Approx = [];
            
            eval([name ' = this;']);
            save(matfile,name);
            
            m.Data = d;
            m.Approx = a;
        end
        
    end
    
    methods(Access=protected,Sealed)
        function x0 = getX0(this, mu)
            % Gets the initial value of `x_0(\mu)`.
            %
            % If the estimator is enabled, x0 is extended by the e0
            % components of the error estimator.
            x0 = getX0@models.BaseModel(this, mu);
            if this.ErrorEstimator.Enabled
                x0 = [x0; this.ErrorEstimator.getE0(mu)];
            end
        end
    end
    
    methods(Access=private)
        
        function [t,x,xr,time,timer,t_noerr] = getTrajectories(this, mu, inputidx)
            if nargin < 3
                inputidx=[];
                if nargin < 2
                    mu = [];
                end
            end
            % Perform full simulation (computed trajectories are cached!)
            tic;
            [t,x] = this.FullModel.computeTrajectory(mu, inputidx);
            time = toc;
            % Perform reduced simulation
            this.ErrorEstimator.Enabled = false;
            tic;
            [t,z] = this.computeTrajectory(mu, inputidx);
            xr = this.V*z;%#ok
            t_noerr = toc;
            this.ErrorEstimator.Enabled = true;
            tic;
            [t,z] = this.computeTrajectory(mu, inputidx);
            xr = this.V*z;
            timer = toc;
        end
        
%         function [vals, repmu] = getSamplesForParam(this, pidx)
%             % Gets the samples from the ParamSamples that are equal in all
%             % other params but the one given through pidx.
%             %
%             % Return values:
%             % vals: The sorted, unique values for parameter pidx in
%             % ParamSamples.
%             % repmu: The representative parameter vector that contains the
%             % param values for all others but the pidx' parameter.
%             %
%             % Note: Since there may be more values of the pidx' param but
%             % some having different parameter vectors here the vector of
%             % the first smallest pidx' param is taken as representative
%             % vector.
%             ps = this.ParamSamples;
%             numparams = this.System.ParamCount;
%             numsamples = size(ps,2);
%             paridx = 1:numparams;
%             
%             % Sort values of current param
%             [tmp, idx] = sort(ps(pidx,:));
%             % Get index of lowest value to have something to start
%             % with
%             first = idx(1);
%             % figure out the leftover indices
%             restpar = paridx;
%             restpar(pidx) = [];
%             
%             % get comparing vector (whole column but the current
%             % parameter's index)
%             cmp = ps(restpar,first);
%             % find columns that are equal to cmp in the whole
%             % column but at the current param's index
%             all = sum(repmat(cmp,1,numsamples) == ps(restpar,:),1) == (numparams-1);
%             
%             vals = sort(unique(ps(pidx,all)));
%             repmu = ps(:,first);
%         end
    end
    
    %% Save & Load
    %     methods
    %         function S = saveobj(obj)
    %             % Just save everything straight
    %             S.fData = obj.fData;
    %             S.fSource = obj.fSource;
    %             S.SubpartOffset = obj.SubpartOffset;
    %             S.Range = obj.Range;
    %             S.InitialSize = obj.InitialSize;
    %             S.LevelSetData = obj.LevelSetData;
    %             S.Regions = obj.Regions;
    %             S.Info = obj.Info;
    %             S.View = obj.View;
    %         end
    %
    %         function obj = reload(obj,S)
    %             obj.fData = S.fData;
    %             obj.SubpartOffset = S.SubpartOffset;
    %             % Important: fSource and SubpartOffset have to be set before
    %             % the range parameter is set.
    %             obj.Range = S.Range;
    %             % Leftover props
    %             obj.InitialSize = S.InitialSize;
    %             obj.LevelSetData = S.LevelSetData;
    %             obj.Regions = S.Regions;
    %             obj.Info = S.Info;
    %             obj.View = S.View;
    %         end
    %     end
    %
    %     methods (Static)
    %         function obj = loadobj(S)
    %             a = S.fSource;
    %             obj = segmentation(sourceimage(S.fSource));
    %             obj = reload(obj,S);
    %         end
    %     end
    
end

