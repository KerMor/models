classdef BaseFullModel < models.BaseModel
    %BASEFULLMODEL The base class for any KerMor detailed model
    %   Implementers of custom models are to inherit from this base class
    %   in order for it to work with KerMor.
    %   For custom models, the properties of this class (combined with
    %   those from BaseModel) can be set to influence the model behaviour
    %   and reduction methods.
    %   For the implementation of custom dynamical systems, refer to
    %   BaseDynSystem.
    %
    % See also: models BaseModel BaseDynSystem
    %
    % @author Daniel Wirtz @date 16.03.2010
    
    properties
        % The sampling strategy the Model uses
        %
        % See also: sampling BaseSampler
        Sampler;
        
        % The full model's data container.
        % Defaults to an empty container.
        %
        % See also: ModelData
        Data;
        
        % The reduction algorithm for subspaces
        %
        % See also: spacereduction BaseSpaceReducer
        SpaceReducer;
        
        % The approximation method for the CoreFunction
        %
        % Defaults to scalar kernel SVR regression
        Approx;
    end
    
    methods
        
        function this = BaseFullModel
            % Creates a new instance of a full model.
            
            % Setting default values for properties that are handle classes
            % will have the negative side-effect of having each instance of
            % BaseFullModel initialized with the SAME instance of the
            % Sampler, Approx etc. instances which of course is NOT
            % desireable.
            % See
            % http://www.mathworks.com/access/helpdesk/help/techdoc/matlab_oop/bsdtcz7.html#bsdu1g9-1
            % for details.
            
            % Setup default values for the full model's components
            this.Sampler = sampling.RandomSampler;
            this.SpaceReducer = spacereduction.PODReducer;
            this.Approx = approx.CompWiseSVR;
            this.Data = models.ModelData;
        end
        
        function off1_generateSamples(this)
            % Offline phase 1: Sample generation.
            
            % Sampling
            if ~isempty(this.Sampler)
                this.Data.ParamSamples = this.Sampler.generateSamples(this);
            end
        end
        
        function off2_generateSnapshots(this)
            % Offline phase 2: Snapshot generation.
            
            ps = this.Data.ParamSamples;
            
            % Need minimum "one" for loops.
            num_samples = max(1,this.Data.SampleCount);
            num_inputs = max(1,this.System.InputCount);
            num_times = length(this.Times);
            
            % Compute system dimension using x0.
            mu = [];
            if this.System.ParamCount > 0
                mu = zeros(this.System.ParamCount,1);
            end
            dims = length(this.System.x0(mu));
            
            % Initialize snapshot array
            snapshots = zeros(dims, length(this.Times), num_samples, num_inputs);
            f_val = zeros(dims, length(this.Times), num_samples, num_inputs);
            
            try
                wh = waitbar(0,'Initializing snapshot generation...');
                cnt = 1;
                % Iterate through all input functions
                for inidx = 1:num_inputs
                    % Iterate through all parameter samples
                    for pidx = 1:num_samples
                        
                        % Check for no parameters
                        if isempty(ps)
                            mu = [];
                        else
                            mu = ps(:,pidx);
                        end
                        % Check for no inputs
                        if this.System.InputCount == 0
                            inputidx = [];
                        else
                            inputidx = inidx;
                        end
                        
                        % Display
                        perc = cnt/(num_inputs*num_samples);
                        waitbar(perc,wh,sprintf('Generating snapshots ... %2.0f %%',perc*100));
                        cnt=cnt+1;
                        
                        %% Get ODE function (general function)
                        [t,x] = this.computeTrajectory(mu, inputidx);
                        
                        % Assign snapshot value
                        snapshots(:,:,pidx,inidx) = x;
                        
                        %% Evaluate f at those points
                        for tidx=1:num_times
                            fx = this.System.f.evaluate(x(:,tidx),this.Times(tidx),mu);
                            f_val(:,tidx,pidx,inidx) = fx;
                        end
                    end
                end
                close(wh);
            catch ME
                close(wh);
                rethrow(ME);
            end
            
            this.Data.Snapshots = snapshots;
            this.Data.fValues = f_val;
        end
        
        function off3_generateReducedSpace(this)
            % Offline phase 3: Generate state space reduction
            
            % Clear before running, so that in case of errors the matrix
            % from old reductions is unset.
            this.Data.V = [];
            this.Data.W = [];
            if ~isempty(this.SpaceReducer)
                if size(this.Data.Snapshots,2) == 1
                    % Easy case: Source dimension is already one. Just set V = Id.
                    this.Data.V = 1;
                    this.Data.W = 1;
                    warning('KerMor:spacereduction',['System''s state dimension'...
                        'is already one; no effective reduction.']);
                end
                try
                    wh = waitbar(.5,'Computing reduced space...');
                    [this.Data.V this.Data.W] = this.SpaceReducer.generateReducedSpace(this);
                    close(wh);
                catch ME
                    close(wh);
                    rethrow(ME);
                end
            end
        end
        
        function off4_generateApproximation(this)
            % Offline phase 4: Core function approximation
            if ~isempty(this.Approx)
                this.Approx.approximateCoreFun(this);
            end
        end
        
        function offlineGenerations(this)
            % Performs all large offline computations for model reduction.
            %
            % This method is mainly used to compile all large data for the
            % reduction process. Its separation from the buildReducedModel
            % method is only for separation reasons.
            % It calls all of the offX_ - methods in their order.
            %
            % See also: buildReducedModel
            
            this.off1_generateSamples;
            this.off2_generateSnapshots;
            this.off3_generateReducedSpace;
            this.off4_generateApproximation;
            
            % Set time dirt flag to false as current snapshots fit the
            % times used.
            this.TimeDirty = false;
        end
        
        function reduced = buildReducedModel(this)
            % Builds a reduced model from a full model.
            %
            % Before calling this method ensure that offlineGenerations was
            % called at least once to provide the model's necessary data
            % for the reduction process.
            %
            % See also: offlineGenerations
            % @docupdate
            
            
            if this.TimeDirty 
                error(['The T or dt parameters have been changed since the last offline generations.';...
                       'A call to offlineGenerations is required.']);
            elseif isempty(this.Data) || isempty(this.Data.Snapshots)
                error('No Snapshot data available. Forgot to call offlineGenerations before?');
            end
            reduced = models.ReducedModel(this);
        end
        
        function [t,x] = computeTrajectory(this, mu, inputidx)
            % Overrides the base method in BaseModel. For speed reasons any
            % already computed trajectories are returned without being 
            %
            % Parameters:
            % mu: The parameter `\mu` to use. Set [] for none.
            % inputidx: The input function `u(t)` index to use. Set [] for
            % none.
            %
            % See also: models.BaseModel#computeTrajectory(mu, inputidx);
            
            if ~isempty(this.Data)
                x = this.Data.getTrajectory(mu,inputidx);
                if ~isempty(x)
                    t = this.Times;
                    return;
                end
            end
            [t,x] = computeTrajectory@models.BaseModel(mu, inputidx);
            % @todo
        end
        
    end
    
%     methods(Access=protected,Sealed)
%         function opts = trajectoryCompInit(this, mu, inputidx)%#ok
%             % Implements the template method from models.BaseModel
%             %
%             % Here in the full model nothing is to do yet as only error
%             % computation for reduced systems is performed so far in
%             % ReducedModel.
%             %
%             % See also: models.BaseModel models.ReducedModel
%             
%             % Nothing to do here yet.
%             opts = [];
%         end
%     end
    
    %% Getter & Setter
    methods
        function set.Sampler(this, value)
            this.checkType(value, 'sampling.BaseSampler');%#ok
            this.Sampler = value;
        end
        
        function set.Data(this, value)
            this.checkType(value, 'models.ModelData');%#ok
            this.Data = value;
        end
        
        function set.SpaceReducer(this, value)
            this.checkType(value, 'spacereduction.BaseSpaceReducer');%#ok
            this.SpaceReducer = value;
        end
        
        function set.Approx(this, value)
            this.checkType(value, 'approx.BaseApprox');%#ok
            this.Approx = value;
        end
    end
    
    methods(Static)
        function test_BaseModels
            m = models.BaseFullModel;
            af = dscomponents.AffLinCoreFun;
            af.addSummand(@(t,mu)1, rand(4,4));
            af.addSummand(@(t,mu)sum(mu)*5, rand(4,4)*3);
            m.System.f = af;
            m.System.x0 = @(mu)sin(1:4)';
            m.offlineGenerations;
            red = m.buildReducedModel;
            % Test simulations
            m.simulate();
            red.simulate();
            
            % dont forget to free resources! (static handles seem to
            % persist over several method calls)
            clear af m red;
        end
        
        function test_BareModel
            m = models.BaseFullModel;
            m.SpaceReducer = [];
            m.Approx = [];
            m.Sampler = [];
            A = rand(2,2);
            m.System.f = dscomponents.PointerCoreFun(@(x,t,mu)A*x);
            m.System.x0 = @(mu)sin(1:2);
            m.offlineGenerations;
            red = m.buildReducedModel;
            red.simulate();
            % dont forget to free resources! (static handles seem to
            % persist over several method calls)
            clear af m red;
        end
        
        function test_LinearModel
            ts = testing.testsettings;
            m = ts.m;
            s = m.System;
            s.f = dscomponents.PointerCoreFun(ts.flin);
            s.x0 = ts.x0;
            m.simulate();
            m.offlineGenerations;
            r = m.buildReducedModel;
            r.simulate();
            clear s m r;
        end
        
        function test_LinearModelNoProj
            ts = testing.testsettings;
            m = ts.m;
            m.SpaceReducer = [];
            s = m.System;
            s.f = dscomponents.PointerCoreFun(ts.flin);
            s.x0 = ts.x0;
            m.simulate();
            m.offlineGenerations;
            r = m.buildReducedModel;
            r.simulate();
            clear s m r;
        end
        
        function test_LinearModelNoApprox
            ts = testing.testsettings;
            m = ts.m;
            m.Approx = [];
            s = m.System;
            s.f = dscomponents.PointerCoreFun(ts.flin);
            s.x0 = ts.x0;
            m.simulate();
            m.offlineGenerations;
            r = m.buildReducedModel;
            r.simulate();
            clear s m r;
        end
        
        function test_LinearModelParams
            ts = testing.testsettings;
            m = ts.m;
            m.Approx.ParamKernel = ts.ParamKernel;
            s = m.System;
            s.f = dscomponents.PointerCoreFun(ts.flin_p);
            s.x0 = ts.x0_p;
            for idx = 1:length(ts.params)
                p = ts.params(idx);
                s.addParam(p.Name, [p.MinVal p.MaxVal], p.Desired);
            end
            m.simulate(m.System.getRandomParam);
            m.offlineGenerations;
            r = m.buildReducedModel;
            r.simulate(r.System.getRandomParam);
            clear s m r;
        end
        
        function test_LinearModelInputs
            ts = testing.testsettings;
            m = ts.m;
            s = m.System;
            s.B = dscomponents.PointerInputConv(ts.B);
            s.f = dscomponents.PointerCoreFun(ts.flin);
            s.x0 = ts.x0;
            s.Inputs = ts.Inputs;
            m.simulate([],1);
            m.offlineGenerations;
            r = m.buildReducedModel;
            r.simulate([],1);
            clear s m r;
        end
        
        function test_LinearModelParamsInput
            ts = testing.testsettings;
            m = ts.m;
            m.Approx.ParamKernel = ts.ParamKernel;
            s = m.System;
            s.f = dscomponents.PointerCoreFun(ts.flin_p);
            s.B = dscomponents.PointerInputConv(ts.B_p);
            s.x0 = ts.x0_p;
            for idx = 1:length(ts.params)
                p = ts.params(idx);
                s.addParam(p.Name, [p.MinVal p.MaxVal], p.Desired);
            end
            s.Inputs = ts.Inputs;
            m.simulate(m.System.getRandomParam, 1);
            m.offlineGenerations;
            r = m.buildReducedModel;
            r.simulate(r.System.getRandomParam, 1);
            clear s m r;
        end
        
        function test_NonlinearModel
            ts = testing.testsettings;
            m = ts.m;
            s = m.System;
            s.f = dscomponents.PointerCoreFun(ts.fnlin);
            s.x0 = ts.x0;
            m.simulate();
            m.offlineGenerations;
            r = m.buildReducedModel;
            r.simulate();
            clear s m r;
        end
        
        function test_NonlinearModelParams
            ts = testing.testsettings;
            m = ts.m;
            m.Approx.ParamKernel = ts.ParamKernel;
            s = m.System;
            s.f = dscomponents.PointerCoreFun(ts.fnlin_p);
            s.x0 = ts.x0_p;
            for idx = 1:length(ts.params)
                p = ts.params(idx);
                s.addParam(p.Name, [p.MinVal p.MaxVal], p.Desired);
            end
            m.simulate(m.System.getRandomParam);
            m.offlineGenerations;
            r = m.buildReducedModel;
            r.simulate(r.System.getRandomParam);
            clear s m r;
        end
        
        function test_NonlinearModelInputs
            ts = testing.testsettings;
            m = ts.m;
            s = m.System;
            s.B = dscomponents.PointerInputConv(ts.B);
            s.f = dscomponents.PointerCoreFun(ts.fnlin);
            s.x0 = ts.x0;
            s.Inputs = ts.Inputs;
            m.simulate([],1);
            m.offlineGenerations;
            r = m.buildReducedModel;
            r.simulate([],1);
            clear s m r;
        end
        
        function test_NonlinearModelParamsInput
            ts = testing.testsettings;
            m = ts.m;
            m.Approx.ParamKernel = ts.ParamKernel;
            s = m.System;
            s.f = dscomponents.PointerCoreFun(ts.fnlin_p);
            s.B = dscomponents.PointerInputConv(ts.B_p);
            s.x0 = ts.x0_p;
            for idx = 1:length(ts.params)
                p = ts.params(idx);
                s.addParam(p.Name, [p.MinVal p.MaxVal], p.Desired);
            end
            s.Inputs = ts.Inputs;
            m.simulate(m.System.getRandomParam,1);
            m.offlineGenerations;
            r = m.buildReducedModel;
            r.simulate(r.System.getRandomParam,1);
            clear s m r;
        end
        
        function test_TimeDependentOutput
            ts = testing.testsettings;
            m = ts.m;
            s = m.System;
            s.f = dscomponents.PointerCoreFun(ts.flin);
            s.x0 = ts.x0;
            s.C = dscomponents.PointerOutputConv(@(t,mu)t,true);
            m.simulate();
            m.offlineGenerations;
            r = m.buildReducedModel;
            r.simulate();
            clear s m r;
        end
    end
end

