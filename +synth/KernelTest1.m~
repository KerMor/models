classdef KernelTest1 < models.BaseFullModel & models.BaseDynSystem & dscomponents.ACoreFun & approx.BaseApprox
    % Kernel core function test model 1
    % 
    % This class implements both the model and dynamical system!
    %
    
    properties        
        % The system's dimension
        dim;
        
        % SV's
        sv;
        
        Ma;
        xi;
        sk;
        
        % The maximum error bound
        Cerr;
    end
    
    properties(Access=private)
        %cf;
        Ma_norms;
        maxR;
        default_ci;
        oldxfeat;
    end
    
    methods
%         function this = KernelTest1(dims, pos_flag)
%             
%             if nargin < 2
%                 pos_flag = false;
%                 if nargin < 1
%                     dims = 1000;
%                 end
%             end
%             this.dim = dims;
%             
%             %% Model settings
%             this.Verbose = 0;
%             this.Name = 'Synthetic kernel based test model 1';
%             
%             this.T = 5;
%             this.dt = .05;
%             
%             this.Sampler = [];%sampling.GridSampler;
%             
%             % This class implements a fake Approx subclass to allow access
%             % to the this.Ma property for the error estimator.
%             this.Approx = this;
%             
%             s = spacereduction.PODReducer;
%             s.Mode = 'abs';
%             s.Value = 1;
%             this.SpaceReducer = s;
%             
%             %this.ODESolver = solvers.MLWrapper(@ode45);
%             this.ODESolver = solvers.ExplEuler;
%             
%             %% System settings
%             this.System = this;
%             
%             this.x0 = @(mu)ones(dims,1)*.5;
%             
%             this.f = this;
%             
%             this.Inputs{1} = @(t)0;
%             
%             % Sample bases
%             this.sv = 10;
%             this.xi = repmat(linspace(-20,20,this.sv),this.dim,1);
%             
%             % Function coefficients
%             offset = .5;
%             %offset = 0;
%             if pos_flag
%                 offset = 0;
%             end
%             ai = (rand(1,this.sv)-offset);
%             
%             this.Ma = repmat(ai,dims,1);
%             
%             this.Cerr = 1000;
%             
%             %% BaseCompWiseKernelApprox settings
%             this.sk = kernels.GaussKernel(dims*100);
%             %this.sk = kernels.GaussKernel(2);
%             
%             %% Precomputed stuff for error estimator testing
%             % Precompute the Ma-vector norms
%             this.Ma_norms = sqrt(sum(this.Ma.^2));
%             this.maxR = sqrt(this.sk.Gamma/2);
%             this.default_ci = ones(1,this.sv) * sqrt(2/this.sk.Gamma)*exp(-.5);
%         end    

function this = KernelTest1(dims, pos_flag)
            
            if nargin < 2
                pos_flag = false;
                if nargin < 1
                    dims = 1000;
                end
            end
            this.dim = dims;
            
            %% Model settings
            this.Verbose = 0;
            this.Name = 'Synthetic kernel based test model 1';
            
            this.T = 5;
            this.dt = .05;
            
            this.Sampler = [];%sampling.GridSampler;
            
            % This class implements a fake Approx subclass to allow access
            % to the this.Ma property for the error estimator.
            this.Approx = this;
            
            s = spacereduction.PODReducer;
            s.Mode = 'abs';
            s.Value = 1;
            this.SpaceReducer = s;
            
            %this.ODESolver = solvers.MLWrapper(@ode45);
            this.ODESolver = solvers.ExplEuler;
            
            %% System settings
            this.System = this;
            
            this.x0 = @(mu)ones(dims,1)*.5;
            
            this.f = this;
            
            this.Inputs{1} = @(t)0;
            
            % Sample bases
            this.sv = 10;
            this.xi = repmat(linspace(-20,20,this.sv),this.dim,1);
            
            % Function coefficients
            offset = .5;
            %offset = 0;
            if pos_flag
                offset = 0;
            end
            ai = (rand(1,this.sv)-offset);
            
            this.Ma = repmat(ai,dims,1);
            
            this.Cerr = 1000;
            
            %% BaseCompWiseKernelApprox settings
            this.sk = kernels.GaussKernel(dims*100);
            %this.sk = kernels.GaussKernel(2);
            
            %% Precomputed stuff for error estimator testing
            % Precompute the Ma-vector norms
            this.Ma_norms = sqrt(sum(this.Ma.^2));
            this.maxR = sqrt(this.sk.Gamma/2);
            this.default_ci = ones(1,this.sv) * sqrt(2/this.sk.Gamma)*exp(-.5);
        end        
        
%         function fx = evaluate(this, x, t, mu)
%             % only x is used!
%             fx = this.Ma * this.sk.evaluate(this.xi, x);
%         end
        
        function phi = getPhi(this, zs, t, mu)
            phi = this.sk.evaluate(this.xi, zs);
        end
        
        function c = getLipschitz(this, t, mu)
            c = sum(abs(this.Ma(1,:))) * this.sk.getLipschitz(this.dim);
            %c = this.cf * (exp(-this.Cerr)-1)/this.Cerr;
        end
        
        function c = getLocalLipschitz(this, z, t, mu)
            di = this.xi - repmat(this.Data.V*z,1,this.sv);
            di = sqrt(sum(di.^2));
            case1 = di - this.Cerr - this.maxR > 0;
            case2 = di + this.Cerr - this.maxR < 0;
            b = this.sk.Gamma;
            ci = this.default_ci;
            ci(case1) = (2/b)*(di(case1)-this.Cerr) .* exp(-(di(case1)-this.Cerr).^2/b);
            ci(case2) = (2/b)*(di(case2)+this.Cerr) .* exp(-(di(case2)+this.Cerr).^2/b);
            c = this.Ma_norms*ci';
        end
        
        function c = getLocalLipschitz2(this, z, t, mu)
            di = this.xi - repmat(this.Data.V*z,1,this.sv);
            di = sqrt(sum(di.^2));
            case1 = di - this.Cerr - this.maxR > 0;
            case2 = di + this.Cerr - this.maxR < 0;
            b = this.sk.Gamma;
            ci = this.default_ci;
            ci(case1) = (exp(-(di(case1)-this.Cerr).^2/b) - exp(-(di(case1).^2/b))) / this.Cerr;
            ci(case2) = (exp(-(di(case2).^2/b)) - exp(-(di(case2)+this.Cerr).^2/b)) / this.Cerr;
            c = this.Ma_norms*ci';
        end
        
        function c = getLocalLipschitz3(this, z, t, mu)
            di = this.xi - repmat(this.Data.V*z,1,this.sv);
            di = sqrt(sum(di.^2));
            
            C = this.Cerr;
            bound = this.maxR;
            
            ci = this.default_ci;
            
            xfeat = ones(size(di))*bound;
            update = abs(di-bound) < C;
            xfeat(update) = this.newt(bound+sign(bound-di(update)),di(update),1e-7,bound);
            left = di + C - xfeat < 0;
            right = di - C - xfeat > 0;
            center = ~left & ~right;
        
            ci(left) = (this.sk.evaluateScalar((di(left))) - this.sk.evaluateScalar((di(left)+C))) / C;
            ci(right) = (this.sk.evaluateScalar((di(right)-C)) - this.sk.evaluateScalar((di(right)))) / C;
            ci(center) = abs(this.sk.evaluateD1(xfeat(center)));
            
            c = this.Ma_norms*ci';         
        end
        
        function xtmp = newt(this, x, xfix, tol, bound)
            xtmp = x+2*tol;
            while any(abs(xtmp-x) > tol)
                g = this.sk.evaluateD1(x) - (this.sk.evaluateScalar(x)-this.sk.evaluateScalar(xfix))./(x-xfix);% - max(0,sign(x0-bound)*(x-bound)).^2;
                g(isnan(g)) = 0;
                g = g - max(0,sign(xfix-bound).*(x-bound)).^2;
                dg = this.sk.evaluateD2(x) - g./(x-xfix);% - max(0,sign(x0-bound)*(x-bound)) .* (sign(x0-bound)*(x-bound) > 0);
                dg(isnan(dg)) = 0;
                dg = dg - max(0,sign(xfix-bound).*(x-bound)) .* (sign(xfix-bound).*(x-bound) > 0);
                xtmp = x;
                x = x + g./dg;
            end
        end

        function c = getcfi(this, z, C, t, mu)
            C = 100;
            di = this.xi - repmat(this.Data.V*z,1,this.sv);
            di = sqrt(sum(di.^2));
            case1 = di - C >= 0;
            case2 = ~case1;
            b = this.sk.Gamma;
            t2 = exp(-((di+C).^2/b));
            ci(case1) = (exp(-(di(case1)-C).^2/b) - t2(case1));
            ci(case2) = (1 - t2(case2));
            c = this.Ma_norms*ci';
        end
                
        function projected = project(this, V, W)
            % Implements ACoreFun(::IProjectable).project
            % no projection for this model as there are only two
            % dimensions.
            projected = this.clone;
            projected.Ma = W'*this.Ma;
            % Rotation invariant kernel!
            projected.xi = W'*this.xi;
        end
        
        function showBaseFun(this)
            % Debug method; displays the core function for each parameter
            % sample.
            figure;
            x = repmat(linspace(-50,50,max(this.sv*5,100)),this.dim,1);
            fx = this.evaluate(x);
            plot(x(1,:),fx(1,:),'r');
            xlabel('x'); ylabel('f(x)');
            title('KernelTest1 base function');
        end
        
    end
    
    %% Functions from BaseCompWiseKernelApprox
    methods(Access=protected)
        
        function fx = evaluate_approximation(this, x)
            % Function is the same!
            fx = this.evaluate(x,[],[]);
        end
        
        function gen_approximation_data(this, xi, ti, mui, fxi)%#ok
            %xin = sqrt(sum(this.xi.*this.xi));
            %Man = sqrt(sum(this.Ma.*this.Ma));
            %this.cf = sum(Man .* exp(-xin));
        end
        
        function projApprox = customProject(this, V,W)
            projApprox = this.project(V,W);
        end
        
        function copy = clone(this)
            copy = models.synth.KernelTest1;
            copy.sk = this.sk;
            copy.dim = this.dim;
            copy.sv = this.sv;
            copy.Ma = this.Ma;
            copy.xi = this.xi;
            copy = clone@approx.BaseApprox(this,copy);
        end
    end
    
    methods(Static)
        
        function [r1,r2] = runEstimatorTest(testnum)
            if nargin == 0
                testnum = 1;
            end
            eval(sprintf('r1 = models.synth.KernelTest1.runTest%d;',testnum));
            m = r1.FullModel;
            r2 = m.buildReducedModel;
            r2.ErrorEstimator = error.CompWiseKernelEstimator2(r2);
            r2.analyze;
        end
        
        function r = runTest1(varargin)
            m = models.synth.KernelTest1(varargin{:});
            %m.ODESolver = solvers.Heun;
            %m.showBaseFun;
            m.offlineGenerations;
            r = m.buildReducedModel;
            r.analyze([],1);
        end
        
        function r = runTest2(varargin)
            m = models.synth.KernelTest1(varargin{:});
            
            m.System.Inputs{1} = @(t)4;
            m.System.B = dscomponents.LinearInputConv(ones(m.dim,1));
            
            m.offlineGenerations;
            r = m.buildReducedModel;
            r.analyze;
        end
        
        function r = runTest3(varargin)
            m = models.synth.KernelTest1(varargin{:});
            
            m.System.x0 = @(mu)rand(m.dim,1);
            
            m.offlineGenerations;
            r = m.buildReducedModel;
            r.analyze;
        end
        
        function r = runTest4(varargin)
            m = models.synth.KernelTest1(varargin{:});
            
            m.System.x0 = @(mu)rand(m.dim,1);
            V = ones(m.dim,1)*sqrt(1/m.dim);
            m.SpaceReducer = spacereduction.ManualReduction(V);
            
            m.offlineGenerations;
            r = m.buildReducedModel;
            r.analyze;
        end
        
        function r = runTest5(varargin)
            m = models.synth.KernelTest1(varargin{:});
            
            m.System.B = dscomponents.LinearInputConv(rand(m.dim,1));
            m.System.Inputs{1} = @(t)4;
            
            m.offlineGenerations;
            r = m.buildReducedModel;
            r.analyze;
        end
        
        function r = runTest6(varargin)
            m = models.synth.KernelTest1(varargin{:});
            
            m.System.B = dscomponents.LinearInputConv(rand(m.dim,1));
            m.System.Inputs{1} = @(t)4;
            
            V = ones(m.dim,1)*sqrt(1/m.dim);
            m.SpaceReducer = spacereduction.ManualReduction(V);
            
            m.offlineGenerations;
            r = m.buildReducedModel;
            r.analyze;
        end
        
        function r = runTest7(varargin)
            m = models.synth.KernelTest1(varargin{:});
            
            m.System.Inputs{1} = @(t)4;
            
            B = ones(m.dim,1);
            B(1:m.dim/2) = -1;
            m.System.B = dscomponents.LinearInputConv(B);
            
            m.offlineGenerations;
            r = m.buildReducedModel;
            r.analyze;
        end
        
        function r = runTest8(varargin)
            m = models.synth.KernelTest1(varargin{:});
            
            m.System.Inputs{1} = @(t)4;
            
            B = ones(m.dim,1);
            B(1:m.dim/2) = -1;
            m.System.B = dscomponents.LinearInputConv(B);
            
            V = ones(m.dim,1)*sqrt(1/m.dim);
            m.SpaceReducer = spacereduction.ManualReduction(V);
            
            m.offlineGenerations;
            r = m.buildReducedModel;
            r.analyze;
        end
        
        function r = runTest9(varargin)
            m = models.synth.KernelTest1(varargin{:});
            
            m.System.Inputs{1} = @(t)4;
            
            m.System.x0 = @(mu)(rand(m.dim,1)-.5)*3;
            
            B = ones(m.dim,1);
            B(1:m.dim/2) = -1;
            m.System.B = dscomponents.LinearInputConv(B);
            
            V = ones(m.dim,1)*sqrt(1/m.dim);
            m.SpaceReducer = spacereduction.ManualReduction(V);
            
            m.offlineGenerations;
            r = m.buildReducedModel;
            r.analyze;
        end
        
        function r = runTest10(varargin)
            m = models.synth.KernelTest1(varargin{:});
            m.T = 20;
            
            m.System.Inputs{1} = @(t)sin(2*t);
            
            m.System.x0 = @(mu)(rand(m.dim,1)-.5)*3;
            
            B = ones(m.dim,1);
            B(1:m.dim/2) = -1;
            m.System.B = dscomponents.LinearInputConv(B);
            
            V = ones(m.dim,1)*sqrt(1/m.dim);
            m.SpaceReducer = spacereduction.ManualReduction(V);
            
            m.offlineGenerations;
            r = m.buildReducedModel;
            r.analyze;
        end
        
        function r = runTest11(varargin)
            m = models.synth.KernelTest1(varargin{:});
            m.T = 20;
            
            m.System.B = dscomponents.LinearInputConv(rand(m.dim,1));
            m.System.Inputs{1} = @(t)sin(2*t);
            
            %m.System.x0 = @(mu)(rand(m.dim,1)-.5)*3;
            
            %V = ones(m.dim,1)*sqrt(1/m.dim);
            %m.SpaceReducer = spacereduction.ManualReduction(V);
            
            m.offlineGenerations;
            r = m.buildReducedModel;
            r.analyze;
        end
        
        function r = runExplTimeTest(varargin)
            m = models.synth.KernelTest1(varargin{:});
            
            m.System.x0 = @(mu)rand(m.dim,1);
            
            m.offlineGenerations;
            r = m.buildReducedModel;
            r.analyze;
            
            pause;
            
            m.ODESolver = solvers.ExplEuler;
            m.offlineGenerations;
            r = m.buildReducedModel;
            r.analyze;
        end
    end
    
end

